# 스프링 핵심 원리 이해1 - 예제 만들기

비즈니스 요구사항과 설계

요구사항들 중 변동 / 미정인 부분들이 많다. 우리는 무한히 기다릴 수 없다 그렇다면 How?  

역할과 구현을 구분한다. (객체 지향 설계 방법)

인터페이스를 만들고 구현체를 언제든지 갈아끼울 수 있도록 설계하면 된다.

회원 저장소 역할은 각각 메모리 회원 저장소, DB 회원 저장소, 외부 시스템 연동 회원 저장소로 나눈다. 

<img src="/Users/dori/Desktop/29f3080f-59f7-4c74-8fdf-245a95882b5a_Export-8896567f-fbbb-4b00-b2d6-f1379796eedc/스프링 핵심 원리 이해1 - 예제 만들기 39b8caeb238e4a45ac59621e068e6e3d/to/Untitled 1.png" width="40%" height="30%" title="px(픽셀) 크기 설정" alt="image1"></img>

클라이언트는 회원서비스를 바라보고, 회원 서비스는 메모리 회원 저장소를 바라본다.

![Untitled](%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%86%A8%E1%84%89%E1%85%B5%E1%86%B7%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8B%E1%85%B5%E1%84%92%E1%85%A21%20-%20%E1%84%8B%E1%85%A8%E1%84%8C%E1%85%A6%20%E1%84%86%E1%85%A1%E1%86%AB%E1%84%83%E1%85%B3%E1%86%AF%E1%84%80%E1%85%B5%2039b8caeb238e4a45ac59621e068e6e3d/Untitled%201.png)

**회원 서비스 : MemberServicempl**

클래스 다이어그램은 실제 서버를 실행하지 않고 클래스들만 분석해서 볼 수 있는 그림. 구현체들은 동적으로 결정이 남 (서버가 뜰 때 new ~ 해가지고 결정) 그렇기 때문에 클래스다이어그램만으론  판단하기 어려움 그렇기 객체 다이어그램이라는 것이 따로 있다. 

→  클래스 다이어그램은 정적, 객체 다이어그램은 동적 

`단축키 command + n으로 변수들을 구조체로 만들어서 묶는다, 데이터를 가지고 오고 뽑는 getter & setter로 private 값들을 setting 할 수 있다.`

구현체의 위치는 인터페이스와 같이 두지 않는 것이 설계상 좋은데, 예제 난이도 조절을 위해 같은 곳에 둔다. 

여러군데에서 store에 접근하면 동시성 이슈가 생기기 때문에 실무에서는 HashMap<> 대신에 ConcurrentHashMap을 사용해야한다 ! 

자바 꿀팁

soutv, soutm, soutp는 IntelliJ IDEA에서 제공하는 단축키 중 하나로, 각각 다음과 같은 기능을 수행합니다.

- soutv: 현재 선택한 변수의 이름과 값을 출력합니다.
- soutm: 현재 선택한 메서드의 이름을 출력합니다.
- soutp: 현재 선택한 메서드의 파라미터를 출력합니다.
- psvm, enter 누르면  `public static void main(String[] args) {     }` 코드가 생성된다.
- Command + option + V 는 리팩토링 (Extract)

하쒸 대문자 소문자 잘 확인하자,,,,,,,, 오류 찾느라 뒤질 뻔했다 

그러나 Mainmethod으로 매번 확인해가며 테스트 하는 방식은 한계가 있다. 

JUnit 테스트 코드 만드는 방식으로 확인해야 합니다 → 눈으로 콘솔을 보면서 오류가 발생한 부분을 확인, 수정 할 수 있다. 

**회원 도메인 설계의 문제점**

이 코드의 설계상 문제점은 무엇일까요?
다른 저장소로 변경할 때 OCP 원칙을 잘 준수할까요?
DIP를 잘 지키고 있을까요? 의존관계가 인터페이스 뿐만 아니라 구현까지 모두 의존하는 문제점이 있음

주문까지 만들고나서 문제점과 해결 방안을 설명

![Untitled](%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%86%A8%E1%84%89%E1%85%B5%E1%86%B7%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8B%E1%85%B5%E1%84%92%E1%85%A21%20-%20%E1%84%8B%E1%85%A8%E1%84%8C%E1%85%A6%20%E1%84%86%E1%85%A1%E1%86%AB%E1%84%83%E1%85%B3%E1%86%AF%E1%84%80%E1%85%B5%2039b8caeb238e4a45ac59621e068e6e3d/Untitled%202.png)

다이어그램을 보면 할인 정책 역할에 정액할인 정책과 정률 할인 정책으로 나누어져있다. 이처럼 역할(주문 서비스 역할, 할인 정책 역할 등등) 과 구현(정액 할인 정책, 정률할인 정책 등등)을 분리하면 할인 정책이나 회원 저장소 따위를 유연하게 변경할 수 있다. 

비록 구현을 변경하더라도 주문 서비스 구현체는 건드릴 필요가 없다.  

핵심 정리

클라이언트가 주문 서비스에 주문 생성을 하고 주문 서비스가 회원 조회를 하고 할인 정책을 사용해서 결과물을 클라이언트에 반환한다. 

다음 시간엔 정책을 바꿨을 때 잘 작동하는가 확인 할 예정 !
