<h1>Section1</h1>
스프링의 핵심:스프링프레임워크<br>
여러 스프링 기술 편리하게:스프링부트<br>
스프링은 객체지향 언어(자바가 가진 강력한 특징을 살려내는 프레임워크 DI,IOC컨테이너)<br>
<h3>스프링 프레임워크</h3>
<li>핵심기술:DI 컨테이너,Aop 이벤트,기타</li>
<li>웹기술:스프링 MVC</li>
<li>데이터 접근 기술:트랜잭션 JDBC ORM 지원</li>
<li>기술통합: 캐시,이메일 ,원격접근 등</li>
<li>테스트</li>
<h3>스프링부트</h3><br>
스프링을 편리하게 사용할 수 있도록 지원,기본으로 생성<br>
<h3>스프링이란</h3>
<li>스프링 DI 컨테이너 기술</li>
<li>스프링 프레임 워크</li>
<li>스프링 부트,스프링 프레임 워크를 모두 포함한 생태계</li>
<h3>객체 지향 특징 </h3>
"객체들의 모임" 객체는 메세지를 주고 받으며 협력 , 유연하고 변경용이
<h3>다형성이란?</h3>
클라이언트를 변경하지 않고 서버의 구현 기능을 유연하게 변경 할 수 있는게 다형성의 본질이다<br>
스프링은 다형성을 편리하게 사용할 수 있도록 지원하는 기술이라 할 수 있음<br>
<h3>SOLID</h3>
<li>SRP:단일 책임 원칙:한 클래스는 하나의 책임만 가져야 한다.</li>
<li>OCP:개방 폐쇄 원칙:확장에는 열려잇으나 변경에는 닫혀 있어야 함</li>
<li>LSP:리코프 지환 원칙:프로그램의 객체는 하위타입의 인스턴스로 바꿀수 있어야 함.</li>
<li>ISP:인터페이스 분리 원칙:특정 클라이언트를 위한 Interface 여러개가 범용 Interface 하나보다 낫다</li>
<li>DIP:의존 관계 역전 원칙:추상화에 의존해야지 구체화에 의존하면 안된다.</li>
<h3>결론</h3>
스프링은 <em>DI(의존관계,의존성 주입),DI컨테이너 제공 함으로 다형성 +OCP,DIP 가능하게 지원한다.</em>
<h1>Section2</h1><br>
변경 가능성이 높은 것들은 역할과 구현을 분리하는 인터페이스를 적극 활용할 수 있다<br>
회원 클래스 다이어 그램과 회원 객체 다이어그램 중에 차이점 중 하나는 회원클래스 다이어그램은 인터페이스로 연결하여 실제로 무엇이 연결되는지 알수는 없으나 회원 객체 다이어그램은 클라리언트가 실제로 사용하는 것을 화살표로 표시한다<br>
<h3>테스트코드에다가 테스트 하는 이유</h3>
<li>실패했을 때 캐치가 쉽다</li>
<h3>회원 도메인 설계의 문제점(순수 자바코드)</h3>
의존관계가 인터페이스 뿐만 아니라 구현까지 모두 의존하는 문제점<br>
ex)MeberService memberService=new MemberServiceImpl();<br>
<h3>참고</h3>
<li>sout order하면 자동으로 toString 출력된다</li>
<li>enumType은 ==비교가 가능하다</li>
<li>NULL이 들어갈 수 있다면 Long으로 그게 아니면 primitive type으로 해도 상관 없다(long)</li>
<h1>Section3</h1>
<h3>문제점</h3>
<li>우리가 만든 것에 새로운 정책을 추가하고 사용할 때 문제점이 발생한다<br>
<li>OrderServiceImpl에는 DiscountPolicy인터페이스 뿐만 아니라 FixDiscountPolicy인 구체 클레스도 함께 의존하고 있기에 DIP위반이다<br>
<li>정책을 변경하는 순간 OrderServiceImpl(클라이언트코드)도 함께 변경해야 하기 때문에 OCP위반이다</li>
<li>뿐만 아니라 OrderServiceImpl에서 무언가 생성하는 역할을 하는 것이 탐탁지 않다 단일 책임 원칙에 살짝 안맞는다</li>

-->DIP를 위반하지 않게 하려면 인터페이스에만 의존하게 해야하는데?<br>
<h3>해결방법</h3>
<li>누군가가 클라이언트인 OrderServiceImpl에 구현 객체를 생성하고 주입해 주어야한다.</li>
<li>따라서 나의 애플리케이션 전체를 설정하고 구성하는 역할을 하는 AppConfig라는 것을 만들었다.</li>
<li>AppConfig에서 객체를 생성하고 주입해주므로(이 과정을 DI라고 함) 클라이언트 코드는 DIP를 완성하였다</li>
<li>클라이언트 코드에서 생성할 것이 없어지므로 단일책임원칙 까지 잘 지킨다</li>
<li>또한 클라이언트 코드를 변경하지 않아도 정책을 변경할 수 있으니 OCP를 잘 지킨다</li>
--->AppConfig 같은게 필요하다
<h3>참고</h3>
<li>테스트 작성할때 실패 테스트를 만들어야 한다.</li>
<li>AppConfig같은 설정 정보를 사용할 때는 역할과 구현이 잘 보이게 Refactoring 하는 것이 좋다</li>
<li>IoC(제어의 역전)이란 내가 무언가 호출하는 것이 아니라 framework같은 것이 내 코드를 대신 호출해 주는 것이라고 할 수 있다.</li>
ex)Junit은 내가 짠 코드의 실행과 제어권을 가져서 Framework이다.<br>
<li>ApplicationContext는 Spring의 모든 것을 시작하면서 스프링 컨테이너의 역할을 한다. @Bean이라는 것을 다 관리한다라고 생각할것</li>
<h3>결국</h3>
Spring이 DI컨테이너 역할을(DIP,단일책임원칙,OCP을 지킨다)를 하면서 추가적인 좋은 기능을 제공해주니 Spring을 쓴다.<br>
<h1>Section4</h1>
<h3>컨테이너란?</h3>
사용하는 객체들을 담고 있는것,ApplicationContext가 컨테이너 역할을 함<br>
<h3>참고</h3>
<li>자바 코드로 스프링 빈을 등록하면 생성자를 호출하면서 의존관계 주입도 한번에 처리됨.</li>
<li>빈 이름은 항상 다른 이름을 부여 해야 함</li>
<li>부모 타입으로 조회하면 자식 타입도 함꼐 조회하는 대원칙이 있다</li>
<li>스프링 컨테이너는 다양한 형식의 설정 정보를 받아드릴 수 있게 유연하게 설계 되었다.</li>
<li>BeanDefinition이라는 추상화로 다양한 설정 형식을 지원</li>
<h1>Section5</h1>
<h3>스프링 컨테이너의 필요성</h3>
객체 인스턴스가 JVM 안에 딱 하나만 있어야 하는 패턴을 싱글톤 패턴이라고 한다<br>
스프링 없이 순수한 자바 코드로 new 를 한다면 서로 다른 객체가 생성될 것이다<br>
우리는 요청할때마다 새로운 객체를 생성한다면 메모리 낭비가 심하므로 객체가 딱 1개만 생성되고 공유하도록 설계해야 한다<br>
static 을 사용해서 자바 코드로 순수하게 설계할 수 있지만 DIP,OCP 위반 가능성이 커지며 코드가 지저분해지는 단점이 있다<br>
싱글톤 컨테이너(스프링 컨테이너)를 사용한다면 싱글톤 패턴을 위한 지저분한 코드가 들어가지 않아도 된다<br>
<h3>주의점</h3>
<li>특정 클라이어느에 의존적인 필드가 있으면 안된다!</li>
<li>특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다!</li>
<li>가급적 읽기만 가능해야 한다(값을 수정하면 안된다)</li>
<h3>@Configuration 과 싱글톤</h3>
@Configuration이 붙는다면 싱글톤을 보장해준다.<br>
@Configuration 이 없다면 싱글톤이 보장이 안된다.<br>
이 경우 New 해서 생성되는 객체는 Spring 이 관리를 안해준다<br>
<h3>참고</h3>
<li>테스트에서 isSameAs는 ==과 같고 , isEqualTo는 자바의 equal과 같다</li>
<li>객체 인스턴스를 생성하는데 비용이 1000이면 참조 가져오는 비용은 1정도로 엄청 작다</li>
<li>요청할 때마다 새로 꺼내는 경우, http request life cycle 에 맞추어서 빈 라이프 사이클을 맞추거나,<br>http session과 똑같은 life cycle 맞추어서 사용,고객이 들어올때 만들고 나갈때 죽이는 경우 만들거나<br>
할때 Singleton 안쓰는 경우가 있다.(99% singleton)</li>





