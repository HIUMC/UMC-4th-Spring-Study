#Section 1
* 좋은 객체지향?   
1. 다형성 -> 클라이언트에게 영향을 주지않고 새로운 기능을 제공 할 수 있다. (역할과 구현으로 구분했기 때문에 가능함)   
따라서 역할과 구현으로 구분을 하는것이 중요하다.   
클라이언트는 구현대상의 내부구조를 몰라도 되고, 구현 대상이 변경되어도 영향이 없음.   
이때, 역할 == interface, 구현 == class   
하지만, interface가 바뀌면 클라이언트, 서버 모두에 큰 변경이 발생함.   
   
#Section 3   
SOLID   
* SRP: 단일 책임 원칙 -> 하나의 클래스는 하나의 책임만을 가진다.   
* OCP: 개방-폐쇄 원칙 -> 소프트웨어 요소는 확장에는 열려있지만 변경에는 닫혀있어야 한다. -> IoC, DI 등등이 필요함   
* LSP: 리스코프 치환원칙 -> 프로그램의 객체는 정확성을 깨뜨리지 않으면서, 하위타입의 인스턴스로 바꿀 수 있어야한다.   
* ISP: 인터페이스 분리 원칙 -> 특정 클라이언트를 위한 인터페이스 여러개가 범용적인 한개의 인터페이스 보다 낫다. -> 인터페이스를 적당히 쪼개는게 좋다   
* DIP: 의존관계 역전 원칙 -> 구현 클래스에 의존하는것이 아니라, 인터페이스에 의존해야한다.   
다형성 만으로는 SOLID를 철저하게 지키기 힘들기 때문에 DI(의존성 주입)컨테이너 필요!   
   
#Section 4   
스프링 컨테이너와 스프링 빈   
ApplicationContext는 스프링 컨테이너 라고 한다. 이를 통해서 스프링 컨테이너를 만들고 빈을 관리 할 수 있다.   
순서는 크게 두가지로 구성되고 다음과 같다.   
1. 빈은 @Bean 이 붙어있는 메서드가 등록이 되고 이름은 유일해야 한다. 스프링이 설정파일을 훑어보고 @Bean이 붙은 메서드들을 자동으로 등록해준다.   
2. 스프링은 설정 정보의 코드를 보고 자동으로 의존관계를 주입해준다. (return이나 parameter들을 보고 결정한다)   
   
#Section 5   
싱글톤 컨테이너 : 사용자가 요청을 할 때마다 새로운 객체를 만들어서 리턴해주는것은 매우 비효율적이므로 스프링에서는 단 하나의 객체를 생성 후 이를 공유해서 사용한다.   
객체가 두개이상 생성되면 안되기 때문에 private을 사용하여 외부에서 임의로 new 하는 것을 막는다고 생각하면 된다.   
사실 스프링 컨테이너는 @Configuration을 사용하면, 싱글톤 컨테이너로 사용된다!   
주의해야 할 점 -> stateless 해야한다. 즉, 코드상에서 해당 객체의 특정 값을 바꾸는 코드가 있으면 안된다.   
   
#Section 6   
컴포넌트 스캔 : 설정 정보 파일에 @ComponentScan을 사용하면 @Component 어노테이션이 붙은 클래스를 자동을 스캔해서 빈으로 등록해준다. 이때 @Configuration도 등록이된다.   
추가로, 의존 관계를 설정해주어야 하는데, 이는 @Autowired를 사용하여 해결한다. @Component를 작성한 클래스 내부의 생성자에 @Autowired를 추가해준다.   
@ComponentScan의 기본 대상은 @Component, @Controller, @Repository, @Service, @Configuration 이다.   
   
#Section 7   
의존 관계 자동 주입   
크게 4가지가 있지만 중요한 것은 생성자 주입과 수정자 주입(setter 사용) 인것 같다.   
생성자 주입 : 클래스의 생성자에 @Autowired를 씀으로 의존관계를 주입한다. 이때 생성자가 하나밖에 없다면 @Autowired가 생략되어도 자동으로 의존관계가 주입이 된다.   
수정자 주입 : setter를 이용하여 의존관계를 주입하는 것이다. 새로운 메서드를 만들어서 거기에 의존관계 관련 코드를 작성해주면 된다. setter를 만들고 @Autowired를 작성해주면 된다.   
만약 주입할 스프링 빈이 없어도 동작이 필요할 때에는 @Autowired가 오류를 일으킨다. 이때에는 @Autowired(required = false) 로 지정해주면 해결된다. (default는 true이다)   
또한 조회 대상 빈이 두개 이상일때에는 @Autowired에 문제가 생길 수 있다.    
- @Qualifier 를 파라미터에 써두면, @Qualifier를 작성한 클래스를 우선적으로 연결한다.   
- @Primary 를 사용하면 우선권을 가진다. rateDiscountPolicy 클래스에 @Primary를 작성하면 우선순위를 준다.
- 추가로 조회 대상 빈 2개 이상이 모두 필요할 때에는 List와 Map을 사용한다.
